给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，
并返回其长度。如果不存在符合条件的子数组，返回 0。
示例：
输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

滑动窗口解法
int minSubArrayLen(int target, int* nums, int numsSize){ 
    int result = numsSize + 1;
    int length;
    int j;
    int i = 0;
    int sum = 0;
    for(j = 0 ; j < numsSize; j++)
    {
        sum += nums[j];
        while(sum >= target)
        {
            length = j + 1 -i;
            if(length < result)
            {
                result = length;
            }
            sum-=nums[i];
            i++;
        }
    }
    if(result == numsSize+1) return 0;
    return result;
}



给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100]
示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]

双指针解法
int* sortedSquares(int* nums, int numsSize, int* returnSize){
int k = numsSize - 1;
int i = 0;
int j = numsSize - 1;
int* result = (int*)malloc(sizeof(int) * numsSize);
*returnSize = numsSize;
while(i<=j)
{
    if(nums[i]*nums[i] >= nums[j]*nums[j])
    {
        result[k] = nums[i] * nums[i];
        i++;
        k--;
    }
    else 
    {
        result[k] = nums[j] * nums[j];
        j--;
        k--;
    }
}
return result;
}